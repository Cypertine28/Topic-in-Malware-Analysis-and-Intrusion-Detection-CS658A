import pickle
import pandas as pd
import sys
import os
import shutil
import datetime
import logging
import numpy as np
default = open('op_based/target_dict.txt','r').readlines()
op = [s.rstrip('\n') for s in default]
final_op=[]
for p in op:
    s=p.split(" ")[0]
    final_op.append(s)


dataset_df=pd.read_csv("op_based/op_2000.csv")
op_codes=dataset_df.columns
op_codes
min_li=[]
max_li=[]
for i in op_codes:
    min_li.append(dataset_df[i].min())
    max_li.append(dataset_df[i].max())


#loading svm model
f=open('op_based/model_SVM_op.pickle','rb')
svm_model=pickle.load(f)
f.close()
#loading RF model
f=open('op_based/model_RF_op.pickle','rb')
rf_model=pickle.load(f)
f.close()
filename = 'op_based/opcode_ann.h5'
loaded_model = pickle.load(open(filename, 'rb'))


def create_opcode_seq(decoded_dir,dalvik_opcodes):
    try:
        smali_dir = os.path.join(decoded_dir, "smali")
        for root, dirs, fnames in os.walk(smali_dir):
            for fname in fnames:
                smali_fname = os.path.join(root, fname)
                with open(smali_fname, mode="r") as bigfile:
                    reader = bigfile.read()
                    for i, part in enumerate(reader.split(".method")):
                        add_newline = False
                        if i!=0:
                            method_part=part.split(".end method")[0]
                            method_body = method_part.strip().split('\n')
                            for line in method_body:
                                # print(method_body)
                                if not line.strip().startswith('.') and not line.strip().startswith('#') and line.strip():
                                    method_line = line.strip().split()
                                    if method_line[0] in dalvik_opcodes:
                                        add_newline = True
                                        dalvik_opcodes[method_line[0]]+=1
                
        return dalvik_opcodes
    except Exception as e:
        logging.error('Exception occured during opseq creation {0}'.format(str(e)))
        return False
    
def classify(apk,i):
	d={}
	apk_dir=apk
	s=i.replace(".apk",'')
	apktoolcmd = "apktool d -r {0}".format(apk_dir)
	os.system(apktoolcmd)
	op_dict={}
	with open("op_based/target_dict.txt") as fop:
		for jk in fop:
			p=jk.strip().split()[0]
			op_dict[p]=0
	res=create_opcode_seq("./"+s,op_dict)
	qwer={}
	for i in res:
		if i not in qwer:
			qwer[i]=res[i]
	# print(res)
	j=0
	for jk in res:
	    res[jk]=(res[jk]-min_li[j])/(max_li[j]-min_li[j])
	    j=j+1
	d[i]=res
	dataset_df = pd.DataFrame(columns=op_codes)
	dataset_df=dataset_df.append(res, ignore_index=True)
	dataset_df=dataset_df.drop("class",axis=1)
	#according to svm
	op1=svm_model.predict(dataset_df)
	# print(op1)
	#according to rf
	op2=rf_model.predict(dataset_df)
	# print(op2)
	t=dataset_df.iloc[0].to_list()
	t=np.array(t)
	# print(t.shape)
	t=t.reshape(1,-1)
	# print(t.shape)
	t=loaded_model.predict(t)
	if t[0]>=0.52:
		ann_op="Malign"
	else:
		ann_op="Benign"
	# print(ann_op)
	return op1,op2,qwer,ann_op